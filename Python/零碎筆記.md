### Python 中的保留字

^d115f0

|   |   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|---|
|False|True|None|and|as|[assert](<# `assert` 的用法>)|break|class|continue|def|
|del|elif|else|except|finally|for|from|global|if|[[import]]|
|in|is|lambda|nonlocal|not|or|pass|raise|return|try|
|while|[[with]]|yield|

---

### 善用科學記號表示很大或很小的數字

e.g. `1e20`, `1e-5`

---

### The Walrus Operator (`:=`)

在 Python 3.8 之後，可以在 `if`、`for` 與 `while` statement 中使用 Walrus Operator，舉例來說：

```Python
# Before Python 3.8
l = len(s)
if l > 2:
    print(l)

# Since Python 3.8
if (l := len(s)) > 2:
    print(l)
```

---

### 註解

```Python
# 這是單行註解

"""
這是
多行
註解
"""
```

---

### 無限

法一

```Python
float("inf") # 正無限大
float("-inf") # 負無限大
```

法二

```Python
import math
math.inf # 正無限大
-math.inf # 負無限大
```

---

### `__name__ == "__main__"`

任何一個 Python package 以及 module 都會有 `__name__` 這個 attribute，當 package `hello` 在一個 `.py` 檔案中被 import 時，package `hello` 的 `__name__` 就會是  `"hello"`，當 package `hello` 中的某個 module `world` 被 import 進一個 `.py` 檔時，module `world` 的 `__name__` 就會是 `"hello.world"`。然而，當一個 module 在自己內部時，自己的 `__name__` 則會叫做 `"__main__"`。

所以在 module 內部時常會看到 `if __name__ == "__main__":` 這樣的 block 出現在 module 的最後，這個 block 的用意就是告訴 Python Interpreter 只有在「直接運行這個 module」時執行 block 內的程式碼；反之，若從其他 module import 這個 module，就不要執行這個 block 內的程式。利用這個特性，這個 block 可以拿來寫 module 內部的 unit test。

事實上，直接執行一個 module 時，印出的 `__name__` (`"__main__"`) 並不是 module 的 `__name__`，而是 **top-level code enrironment** 的 `__name__`。

---

### 使用 CLI 執行 Python 時常見的 Options

1. `-m`

    加上 `-m` option 後，即可以 module 的 `__name__` 執行指定的 module。所以 `python ./hello/world.py` 就可以寫成 `python -m hello.world`。

2. `-B`

    執行 Python 時，不會試圖讀取或寫入任何 `.pyc` 檔，因此也就不會產生 `__pycache__` 這個 directory。

---

### 善用 [[Lazy evaluation]] 避免不必要的計算

---

### 不推薦使用 `type` 來做型別檢查，因為有些時候 `type` 的結果並不一定可靠

建議使用 `isinstance` 來做型別檢查。

---

### `eval` 容易有安全漏洞

---

### 習慣使用 [[with]] 自動關閉資源

---

### 盡量不要單獨使用 `except:` 或 `except Exception:`，而是具體的 Exception

---

### `assert` 的用法

`assert <expression>, <message>`

其中 `<expression>` 必須 output 一個 `bool`，`<message>` 必須是一個 `str`。

若 `<expression>` output `True`，則程式就會正常地繼續執行；反之，若 `<expression>` output `False`，則程式會中斷並出現錯誤訊息：

```plaintext
Traceback (most recent call last):
  File ..., line ...
    assert <expression>, <message>
           ^^^^^^^^^^^^
AssertionError: <message>
```

執行一個 Python module 時，若加上 `-0` option（比如 `python my_module.py -0`），則 Python Interpreter 會略過所有 `assert` statement。

加上 `-0` option 實際上是把該 module 的 `__debug__` 這個 magic attribute 設為 `False`，因此，我們可以說 `assert <expression>, <message>` 等價於下方程式碼：

```Python
if __debug__:
    if not experession:
        raise AssertionError(message)
```
