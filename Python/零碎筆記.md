### Python 中的保留字

|   |   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|---|
|False|True|None|and|as|[assert](<# `assert` 的用法>)|break|class|continue|def|
|del|elif|else|except|finally|for|from|global|if|[[import]]|
|in|is|lambda|nonlocal|not|or|pass|raise|return|try|
|while|[[with]]|yield|

---

### 善用科學記號表示很大或很小的數字

e.g. `1e20`, `1e-5`

---

### The Walrus Operator (`:=`)

在 Python 3.8 之後，可以在 `if`、`for` 與 `while` statement 中使用 Walrus Operator，舉例來說：

```Python
# Before Python 3.8
l = len(s)
if l > 2:
    print(l)

# Since Python 3.8
if (l := len(s)) > 2:
    print(l)
```

使用 Walrus Operator 時須記得加上必要的 `( )`，否則意思可能完全不同。

比如像上面的例子中，`l` 是 `len(s)`（一個 `int`），但若少了外面的 `( )`（也就是寫成 `if l := len(s) > 2`）則這時候 `l` 就會變成 `len(2) > 2`（一個 `bool`）。

---

### 註解

```Python
# 這是單行註解

"""
這是
多行
註解
"""
```

---

### 無限

法一

```Python
float("inf")  # 正無限大
float("-inf")  # 負無限大
```

法二

```Python
import math

math.inf  # 正無限大
-math.inf  # 負無限大
```

---

### `__name__ == "__main__"`

每一個 Python **package** 以及 **module** 都會有 `__name__` 這個 attribute，==一個 module 在自己內部取自己的 `__name__` 會得到 `"__main__"`==。

取其他被 import 進來的 packages 或 modules 的 `__name__` 就不會得到 `"__main__"`。比如現在有一個 package 叫 `hello`，當 `hello` 被 import 進其他檔案時，`hello` 在該檔案中的 `__name__` 會是  `"hello"`。

假設 `hello` 中有一個 module 叫 `world.py`，當 `world.py` 被 import 進其他檔案時，`world.py` 在該檔案中的的 `__name__` 會是 `"hello.world"`。

所以在 module 內部時常會看到 `if __name__ == "__main__":` 這樣的 block 出現在 module 的最後，這個 block 的用意就是告訴 Python Interpreter 只有在「直接運行這個 module」時才要執行 block 內的程式碼；反之，若從其他 module import 這個 module，就不要執行這個 block 內的程式。利用這個特性，這個 block 可以拿來寫 module 內部的 unit test。

>[!Info]
>事實上，直接執行一個 module 時，印出的 `__name__` (`"__main__"`) 並不是 module 的 `__name__`，而是 **top-level code enrironment** 的 `__name__`。

---

### 使用 CLI 執行 Python 時常搭配使用的 Options

- `-m`

    以 module 的 `__name__` 執行指定的 module。所以下面兩個的指令效果是一樣的：
    
    ```bash
    python ./hello/world.py
    
    # or
    
    python -m hello.world
    ```

- `-B`

    執行 Python 時，不會試圖讀取或寫入任何 `.pyc` 檔，因此也就不會產生 `__pycache__` 這個 directory。

---

### 善用 [[Lazy evaluation]] 避免不必要的計算

---

### 不推薦使用 `type` 來做型別檢查

有些時候 `type` 的結果並不一定可靠，建議使用 `isinstance` 來做型別檢查，或使用 `hasattr` 來檢查物件是否具有某些 attributes。

---

### `eval` 容易有安全漏洞

---

### 習慣使用 [[with]] 自動關閉資源

---

### 盡量不要單獨使用 `except:` 

盡量使用 `except XXException:` 或更完整的 `except Exception as e:`。

---

### `assert` 的用法

```Python
assert <EXPRESSION>, <MESSAGE>
```

其中 `<EXPRESSION>` 必須 output 一個 `bool`，`<MESSAGE>` 則必須是一個 `str`。

若 `<EXPRESSION>` output `True`，則程式就會正常地繼續執行；反之，若 `<EXPRESSION>` output `False`，則程式會中斷並出現錯誤訊息：

```plaintext
Traceback (most recent call last):
  File ..., line ...
    assert <expression>, <message>
           ^^^^^^^^^^^^
AssertionError: <message>
```

執行一個 Python module 時，若加上 `-0` option，則 Python Interpreter 會略過所有 `assert` statement。

e.g.

```bash
python my_module.py -0
```

加上 `-0` option 實際上是把該 module 的 `__debug__` 這個 magic attribute 設為 `False`，因此，我們可以說：

```Python
assert <EXPRESSION>, <MESSAGE>

# is equivalent to

if __debug__:
    if not <EXPRESSION>:
        raise AssertionError(<MESSAGE>)
```

---

### 旋轉 2D list

```Python
m = [[1, 2], [3, 4]]

# Clockwise rotation
l = list(zip(*m[::-1]))
print(l)  # [[3, 1], [4, 2]]

# Counterclockwise rotation
l = list(zip(*m)[::-1])
print(l)  # [[2, 4], [1, 3]]
```

---

### Flatten 2D list

```Python
m = [[1, 2], [3, 4]]
l = sum(m, [])
print(l)  # [1, 2, 3, 4]
```

---

### Tuple Unpacking

Tuple Unpacking 指的是將一個 tuple 中的各個值一次 assign 給多個變數，舉例而言：

```Python
a, b = (1, 2)

print(a)  # 1
print(b)  # 2

# 其實可以不用寫 `(` 與 `)`
a, b = 1, 2
```

「變數交換值」可以使用 Tuple Unpacking 來一行解決：

```Python
a, b = b, a

# 在其他語言中，必須使用 temp 才能交換內容，所以至少會有三行
temp = a
a = b
b = temp
```

### List Unpacking

與 tuple unpacking 類似：

```Python
a, b = [1, 2]

print(a)  # 1
print(b)  # 2
```

---

### List Comprehension

```python
l = [i**2 for i in range(10)]

# is equivalent to

l = []
for i in range(10):
    l.append(i**2)
```

- 請注意它與 [[Generator and the yield Statement#Generator Expression|Generator  Expression]] 的差異
- 使用 for loop 比較沒有效率

### Set Comprehension

```Python
l = [1, 2, 2, 3]

# The result of the following three approaches are same:

# Approach 1 (Set Conversion)
s = set(l)

# Approach 2 (Set Comprehension)
s = {num for num in l}

# Approach 3
s = set()
for num in l:
    s.add(num)
```

與 List Comprehension 類似，Approach 3 是三者之中最沒效率的。

### Dict Comprehension

```Python
l = [["a", 1], ["b", 2], ["c", 3]]

# The result of the following two approaches are same:

# Approach 1 (Dict Conversion)
d = dict(l)

# Approach 2 (Dict Comprehension)
d = {k: v for k, v in l}
```

---

### Chained Assignment

```Python
a = b = 10;

# is equivalent to

a = 10
b = 10
```

當 assign 給各個變數的值的型態是基本資料型態時，各變數間不會連動，但若 assign 給各個變數的值是一個物件時，各變數間就會連動，比如說：

```Python
i = j = 10
i = 0
print(i, j)  # 0, 10

a = b = [10]
a[0] = [0]
print(a, b)  # [0], [0]
```

---

### `enumerate`

使用 `enumerate` 同時獲取序列迭代的 index 和 value：

```Python
l = ['a', 'b', 'c']
for idx, char in enumerate(l):
    print(idx, char)
# 0, 'a'
# 1, 'b'
# 2, 'c'
```

---

### 使用 `get` 處理 dict 中找不到 Key 的狀況

```Python
aDict[k] = aDict.get(k, 0) + 1

# is equivalent to

if k in aDict:
    aDict[k] += 1
else:
    aDict[k] = 1
```

---

### 對 dict 做字串格式化

```Python
info = {
    "firstName": "Bob",
    "lastName": "Douglas",
    "age": 25
}

greeting = "My name is %(firsName)S %(lastName)S, I'm %(age)S years old." % info
```

---

### 使用 `contextlib.suppress` 取代 `try-except-pass`

```Python
from contextlib import suppress

with suppress(FileNotFoundError):
    os.remove('somefile.tmp')

# is equivalent to

try:
    os.remove('somefile.tmp')
except FileNotFoundError:
    ...
```

---

### 「有順序地」選出一個 list 中的 Unique Values

以一個含有若干 characters 的 list `l` 為例，使用 `set(l)` 或 [[#Set Comprehension]] 選出的 characters 順序會被打亂，不一定會與本來 `l` 中的順序一樣。

若想要維持順序，則可以使用 `dict.fromkeys`：

```Python
l = ["a", "c", "b", "a", "d", "a"]
s = list(dict.fromkeys(l))
```

`dict.fromekeys` 會將第一個位置的參數（必須是一個 [[Iterable & Iterator|iterable]]）中的元素按照順序逐一放入一個原本為空的 dictionary，由於在 ==Python 3.7 後，dict 中的 keys 是有順序的==，這個順序會與「每個 key 第一次被塞入 dict 的順序」相同，因此這個做法可以在維持元素在原 iterable 中的順序的情況下，同時保證元素的唯一性。

---
