{
	"nodes":[
		{"id":"1c3713f729dc1bae","type":"group","x":-1533,"y":341,"width":3055,"height":1239,"label":"Example Code"},
		{"id":"4360a914ebcb4247","type":"text","text":"## Threading","x":-158,"y":-22,"width":302,"height":100,"color":"6"},
		{"id":"3b210381f5a70b1c","type":"text","text":"#### `asyncio` library","x":-1106,"y":-244,"width":233,"height":64,"color":"5"},
		{"id":"6ec34d8a7302f01e","type":"text","text":"[官方文件](https://docs.python.org/3/library/asyncio.html)","x":-1345,"y":-372,"width":140,"height":54},
		{"id":"e3b73db1a213e0bc","type":"text","text":"提供了另一種達到 concurrency 的方法","x":-1420,"y":-260,"width":215,"height":96},
		{"id":"de3bca080d22d66c","type":"text","text":"`join`","x":-1077,"y":-1023,"width":104,"height":54},
		{"id":"957bbc7b99da88fe","type":"text","text":"`class Queue`","x":-941,"y":-867,"width":171,"height":55},
		{"id":"f33e659c9761687a","type":"text","text":"block the current thread until the queue becomes emtpy","x":-1177,"y":-1192,"width":298,"height":100},
		{"id":"80b697bdfecb0f45","type":"text","text":"提供了一個 thread-safe interface，可供多個 threads 讀寫，以達到 concurrency","x":-1363,"y":-736,"width":282,"height":135},
		{"id":"ef03f7cbd4b1a07c","type":"text","text":"#### `queue` library","x":-959,"y":-699,"width":210,"height":61,"color":"5"},
		{"id":"2140b9653f50e641","type":"text","text":"[官方文件](https://docs.python.org/3/library/queue.html)","x":-924,"y":-555,"width":140,"height":54},
		{"id":"38b4f5cf62c42f21","type":"text","text":"#### `threading` library","x":-135,"y":-405,"width":256,"height":65,"color":"5"},
		{"id":"6715ebbecee7b4a7","type":"text","text":"#### Single Queue + Multiple Consumers\n\n```Python\nfrom queue import Queue, Empty\nfrom threading import current_thread, Thread\n\nq = Queue(5)\n\n\ndef consume() -> None:\n    global q\n\n    while True:\n        try:\n            task = q.get(timeout=2)\n        except Empty:\n            print(f\"Breaking {current_thread().name}.\")\n            break\n        print(f\"{current_thread().name} is working on {task}.\")\n        task()  # working on task\n        q.task_done()\n        print(f\"{task} done.\")\n\ndef task():\n    a = []\n    for i in range(250_000):\n        a.append(i)\n    while a:\n        a.pop(0)\n\nconsumer_1 = Thread(target=consume, name=\"consumer_1\")\nconsumer_2 = Thread(target=consume, name=\"consumer_2\")\nconsumer_1.start()\nconsumer_2.start()\n\nfor i in range(7):\n    q.put(task)\n    print(\"Task put.\")\n\nq.join()  # (optional) block the main thread until the queue is empty\nprint(\"All tasks done!\")\n\nconsumer_1.join()  # Do this only if `timeout` was specified when calling `q.get`\nif not consumer_1.is_alive():\n    print(\"The thread for consumer_1 is closed because it's been idle for too long.\")\nconsumer_2.join()  # Do this only if `timeout` was specified when calling `q.get`\nif not consumer_2.is_alive():\n    print(\"The thread for consumer_2 is closed because it's been idle for too long.\")\n```","x":648,"y":375,"width":854,"height":1169},
		{"id":"e1cd19d8dda5e4a9","type":"text","text":"#### Threading with Lock\n\n```Python\nfrom time import sleep\nfrom threading import Lock, Thread\n\nN = 0\nLOCK = Lock()\n\n\ndef increase_n() -> None:\n    global N, LOCK\n    with LOCK:\n        # simulate fetching data from the database\n        sleep(0.1)  # simulate i/o bound\n        local_n = N\n        print(f\"Read {local_n}.\")\n\n        # simulate writing data into the database\n        sleep(0.5)  # simulate i/o bound\n        N = local_n + 1\n        print(f\"Write {N}.\")\n\n\nthread_1 = Thread(target=increase_n)\nthread_2 = Thread(target=increase_n)\n\nthread_1.start()\nthread_2.start()\n\nthread_1.join()\nthread_2.join()\n\nprint(f\"N = {N}\")  # N = 2\n```","x":-906,"y":375,"width":541,"height":857},
		{"id":"cbc26e6f087c0854","type":"text","text":"#### Single Queue + Single Consumer\n\n```Python\nfrom queue import Queue, Empty\nfrom threading import current_thread, Thread\n\nq = Queue(5)\n\n\ndef consume() -> None:\n    global q\n\n    while True:\n        try:\n            task = q.get(timeout=2)\n        except Empty:\n            print(f\"Breaking {current_thread().name}.\")\n            break\n        print(f\"{current_thread().name} is working on {task}.\")\n        task()  # working on task\n        q.task_done()\n        print(f\"{task} done.\")\n\ndef task():\n    a = []\n    for i in range(250_000):\n        a.append(i)\n    while a:\n        a.pop(0)\n\nconsumer = Thread(target=consume, name=\"hello_world\")\nconsumer.start()\n\nq.put(task)\nprint(\"Task put.\")\n\nq.put(task)\nprint(\"Task put.\")\n\nq.join()  # (optional) block the main thread until the queue is empty\nprint(\"All tasks done!\")\n\nconsumer.join()  # Do this only if `timeout` was specified when calling `q.get`\nif not consumer.is_alive():\n    print(\"The consumer thread is closed because it's been idle for too long.\")\n```","x":-268,"y":375,"width":806,"height":1102},
		{"id":"b100d07a9ae9ef9d","type":"text","text":"#### Threading without Lock\n\n```Python\nfrom time import sleep\nfrom threading import Thread\n\nN = 0\n\n\ndef increase_n() -> None:\n    global N\n\n    # simulate fetching data from the database\n    sleep(0.1)  # simulate i/o bound\n    local_n = N\n    print(f\"Read {local_n}.\")\n\n    # simulate writing data into the database\n    sleep(0.5)  # simulate i/o bound\n    N = local_n + 1\n    print(f\"Write {N}.\")\n\n\nthread_1 = Thread(target=increase_n)\nthread_2 = Thread(target=increase_n)\n\nthread_1.start()\nthread_2.start()\n\nthread_1.join()\nthread_2.join()\n\nprint(f\"N = {N}\")  # N = 1\n```","x":-1513,"y":375,"width":512,"height":834},
		{"id":"02d1099b2a2a9de0","type":"text","text":"```Python\nfrom typing import Callable\nfrom threading import Thread\nimport os\n\ndef threading(func: Callable, n: int, thread_count: int) -> None:\n    threads = []\n    for _ in range(thread_count):\n        # divide tasks to every threads\n        threads.append(Thread(target=func, args=(n // thread_count,)))\n\n    for thread in threads:\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\ndef f(n: int) -> int:  # CPU-bound task\n    a = 0\n    for i in range(n):\n        a += i ** 0.5\n    return a\n\nif __name__ == \"__main__\":\n    threading(f, 1_000_000, os.cpu_count())\n```","x":-2456,"y":375,"width":720,"height":642},
		{"id":"be770ce6ba0c4941","type":"text","text":"Python program 開始運行時所使用的 thread","x":627,"y":-578,"width":239,"height":100},
		{"id":"746723b8ae06a448","type":"text","text":"`threading.main_thread()`","x":627,"y":-692,"width":293,"height":64},
		{"id":"7b6bfb9707395476","type":"text","text":"`class Lock`","x":84,"y":-745,"width":164,"height":54},
		{"id":"b51b14f3ffc969b8","type":"text","text":"context manager","x":334,"y":-747,"width":193,"height":58},
		{"id":"5de19fa074dff6fa","type":"text","text":"`put`","x":-901,"y":-1023,"width":94,"height":54},
		{"id":"09d668e10e7cbda8","type":"text","text":"`join`","x":-167,"y":-900,"width":104,"height":54},
		{"id":"4e969f1ffcc32ad8","type":"text","text":"**main** thread","x":304,"y":-555,"width":162,"height":54},
		{"id":"fc7c5bdee2b8b10d","type":"text","text":"`class Thread`","x":-299,"y":-745,"width":184,"height":56},
		{"id":"ddc11f9727e87bd2","type":"text","text":"`start`","x":-382,"y":-900,"width":114,"height":54},
		{"id":"b0385768271ceff0","type":"text","text":"`acquire`","x":-7,"y":-900,"width":134,"height":54},
		{"id":"99bb782c9b077c07","type":"text","text":"`release`","x":200,"y":-900,"width":134,"height":54},
		{"id":"42e1455b3e851870","type":"text","text":"使這個 thread 變成一個 blocking thread","x":-228,"y":-1063,"width":226,"height":98},
		{"id":"5e6d1b0e2b25dc83","type":"text","text":"main thread 會在這個 thread 終止後才繼續走下去","x":-252,"y":-1226,"width":275,"height":100},
		{"id":"0122816ca767f863","type":"text","text":"`get`","x":-738,"y":-1023,"width":94,"height":54},
		{"id":"ef30e4151c34c943","type":"text","text":"Python 無法透過 threading 加速 [[CPU-bound task]] 的運行","x":244,"y":-22,"width":290,"height":100},
		{"id":"d72e0bdbb3535daf","type":"text","text":"在多數程式語言中，multi-threaded program 都會利用多個 CPU cores [[Operating System/零碎筆記#Concurrency vs. Parallelism|平行運算]]，從而加快運算速度。然而 Python（更精準的說是 CPython）中有 [[GIL]]，這使得==同一時間只有一個 thread 可以執行 Python code==，也就只會用到一個 CPU core。所以在 Python 使用 threading 無法做到 parallelism，只能在多個 threads 間進行切換，達到 [[Operating System/零碎筆記#Concurrency vs. Parallelism|concurrency]] 的效果。","x":683,"y":-94,"width":549,"height":244},
		{"id":"07185f0a4a76bb74","type":"text","text":"**daemon** thread","x":304,"y":-332,"width":190,"height":57},
		{"id":"6e8457c092df8c70","type":"text","text":"當剩下的 threads 都是 daemon threads，且該 thread 為 non-blocking thread 時，整個 Python program (main thread) 就會終止（然後剩下的 daemon threads 就會被強制終止）。換句話說：\"A daemon thread won't prevent the main thread from terminating (while a non-daemon thread will).\"","x":594,"y":-426,"width":486,"height":244},
		{"id":"51c7377433b0f7f2","type":"text","text":"但這個現象在 jupyter notebook 中不一樣。在 jupyter nobook 中，單個 cell 的 main thread 不會因為 non-daemon thread 而不 terminate。","x":1199,"y":-389,"width":351,"height":171},
		{"id":"85adc15714bfce5d","type":"text","text":"[官方文件](https://docs.python.org/3/library/threading.html)","x":234,"y":-209,"width":140,"height":54}
	],
	"edges":[
		{"id":"71d4dd8e01b877fd","fromNode":"4360a914ebcb4247","fromSide":"top","toNode":"38b4f5cf62c42f21","toSide":"bottom"},
		{"id":"81ef212dbe5e421d","fromNode":"38b4f5cf62c42f21","fromSide":"left","toNode":"ef03f7cbd4b1a07c","toSide":"right","fromEnd":"arrow","color":"5","label":"互補"},
		{"id":"95cf8cd3d0d67361","fromNode":"38b4f5cf62c42f21","fromSide":"left","toNode":"3b210381f5a70b1c","toSide":"right","fromEnd":"arrow","color":"5","label":"替代"},
		{"id":"5c7d372576a38a48","fromNode":"4360a914ebcb4247","fromSide":"right","toNode":"ef30e4151c34c943","toSide":"left"},
		{"id":"8a7763b569e883eb","fromNode":"ef30e4151c34c943","fromSide":"right","toNode":"d72e0bdbb3535daf","toSide":"left"},
		{"id":"8447d9715a697752","fromNode":"38b4f5cf62c42f21","fromSide":"right","toNode":"07185f0a4a76bb74","toSide":"left"},
		{"id":"e8e7cac4ee35ec46","fromNode":"07185f0a4a76bb74","fromSide":"right","toNode":"6e8457c092df8c70","toSide":"left"},
		{"id":"86d319b26988eb3b","fromNode":"38b4f5cf62c42f21","fromSide":"right","toNode":"85adc15714bfce5d","toSide":"left"},
		{"id":"cf14c8c5d56d5bff","fromNode":"38b4f5cf62c42f21","fromSide":"top","toNode":"fc7c5bdee2b8b10d","toSide":"bottom"},
		{"id":"eeaff0bca7dee4d7","fromNode":"38b4f5cf62c42f21","fromSide":"top","toNode":"7b6bfb9707395476","toSide":"bottom"},
		{"id":"21b8430f6bb53418","fromNode":"fc7c5bdee2b8b10d","fromSide":"top","toNode":"ddc11f9727e87bd2","toSide":"bottom"},
		{"id":"6f563d1c3ec2b8db","fromNode":"fc7c5bdee2b8b10d","fromSide":"top","toNode":"09d668e10e7cbda8","toSide":"bottom"},
		{"id":"cdafe9a2b89d8290","fromNode":"7b6bfb9707395476","fromSide":"top","toNode":"b0385768271ceff0","toSide":"bottom"},
		{"id":"23fe331ef9b3d0fe","fromNode":"7b6bfb9707395476","fromSide":"top","toNode":"99bb782c9b077c07","toSide":"bottom"},
		{"id":"b33d76e119643dd3","fromNode":"ef03f7cbd4b1a07c","fromSide":"left","toNode":"80b697bdfecb0f45","toSide":"right"},
		{"id":"d0cc09beb54ce032","fromNode":"ef03f7cbd4b1a07c","fromSide":"bottom","toNode":"2140b9653f50e641","toSide":"top"},
		{"id":"1732148f5e2ec199","fromNode":"3b210381f5a70b1c","fromSide":"left","toNode":"e3b73db1a213e0bc","toSide":"right"},
		{"id":"b099b67c802b40ec","fromNode":"3b210381f5a70b1c","fromSide":"left","toNode":"6ec34d8a7302f01e","toSide":"right"},
		{"id":"e448ac7679d66b27","fromNode":"ef03f7cbd4b1a07c","fromSide":"top","toNode":"957bbc7b99da88fe","toSide":"bottom"},
		{"id":"d4378cecbe59f589","fromNode":"957bbc7b99da88fe","fromSide":"top","toNode":"0122816ca767f863","toSide":"bottom"},
		{"id":"ef793cb37442bc03","fromNode":"957bbc7b99da88fe","fromSide":"top","toNode":"5de19fa074dff6fa","toSide":"bottom"},
		{"id":"097299e6de945e4e","fromNode":"957bbc7b99da88fe","fromSide":"top","toNode":"de3bca080d22d66c","toSide":"bottom"},
		{"id":"ae2a6938131c8d2e","fromNode":"6e8457c092df8c70","fromSide":"right","toNode":"51c7377433b0f7f2","toSide":"left"},
		{"id":"123e5740ec4f8790","fromNode":"de3bca080d22d66c","fromSide":"top","toNode":"f33e659c9761687a","toSide":"bottom"},
		{"id":"25d4343ddcc1e7a5","fromNode":"09d668e10e7cbda8","fromSide":"top","toNode":"42e1455b3e851870","toSide":"bottom"},
		{"id":"add46fbf735568ac","fromNode":"38b4f5cf62c42f21","fromSide":"right","toNode":"4e969f1ffcc32ad8","toSide":"left"},
		{"id":"eaf9acb34c90f9c1","fromNode":"4e969f1ffcc32ad8","fromSide":"right","toNode":"be770ce6ba0c4941","toSide":"left"},
		{"id":"0481579d0d87ae26","fromNode":"7b6bfb9707395476","fromSide":"right","toNode":"b51b14f3ffc969b8","toSide":"left"},
		{"id":"bf169ee47bf27203","fromNode":"4e969f1ffcc32ad8","fromSide":"right","toNode":"746723b8ae06a448","toSide":"left"},
		{"id":"81ba2b9e4bcc4360","fromNode":"42e1455b3e851870","fromSide":"top","toNode":"5e6d1b0e2b25dc83","toSide":"bottom"},
		{"id":"cc7d5135af9c2a4a","fromNode":"4360a914ebcb4247","fromSide":"bottom","toNode":"1c3713f729dc1bae","toSide":"top"}
	]
}