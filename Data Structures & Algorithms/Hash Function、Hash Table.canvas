{
	"nodes":[
		{"id":"ef217910f14bec4e","type":"group","x":1552,"y":66,"width":535,"height":907,"label":"解決 Hash Collision 的方法"},
		{"id":"f389fc1d07a58b1c","type":"group","x":1053,"y":-1399,"width":499,"height":881,"label":"簡單的 Hash Functions"},
		{"id":"73842961c770f581","type":"group","x":519,"y":-449,"width":483,"height":662,"label":"特色"},
		{"id":"f4e489738c973c82","type":"group","x":-274,"y":-484,"width":364,"height":406,"label":"應用"},
		{"id":"314a30f813de4470","type":"group","x":-860,"y":-223,"width":955,"height":150,"label":"有 O(1) 查詢速度的資料結構"},
		{"id":"78cddbf39f2cc15b","type":"text","text":"只要兩筆資料經過同一個 hash function 後得到的 hash values 不同，就代表它們的原始值不同","x":-387,"y":-821,"width":302,"height":135},
		{"id":"271c87cc8cc5b7d4","type":"text","text":"可以在不知道資料原始值的情況下，驗證另一筆資料是否與該值「不同」","x":13,"y":-821,"width":248,"height":135},
		{"id":"80581dddeea49f78","type":"text","text":"- Data integrity check\n- 資料庫儲存密碼\n- 驗證數位簽章","x":-213,"y":-460,"width":243,"height":170},
		{"id":"f86f8d1d2b74b019","type":"text","text":"輸入一個整數、浮點數或字串，輸出另一段字串，輸出的字串又叫做 hash value、hash code、hash sum 或 hash","x":196,"y":-1258,"width":359,"height":135},
		{"id":"aa47004104c96f1a","type":"text","text":"像是一個人的指紋","x":222,"y":-993,"width":195,"height":58},
		{"id":"8c49bf9b00379b01","type":"text","text":"###### 實務上常用的 Hash Functions\n\n- SHA 系列：SHA-0、SHA-1、SHA-256、SHA-512\n- MD 系列：MD2、MD4、MD5","x":620,"y":-1327,"width":321,"height":205},
		{"id":"2fd997835d4fc628","type":"text","text":"Git 的 commit hash 使用 SHA-1","x":626,"y":-1489,"width":310,"height":64},
		{"id":"c494898a8ce0ffb2","type":"text","text":"#### 參考資料\n\n- [Chaining v.s. Open Addressing](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)","x":-280,"y":-1161,"width":346,"height":123,"color":"2"},
		{"id":"7289a4c60b56d99c","type":"text","text":"雜湊","x":712,"y":-964,"width":88,"height":54},
		{"id":"a196e5ac56db1698","type":"text","text":"## Hash Function","x":379,"y":-804,"width":408,"height":100,"color":"6"},
		{"id":"26accb2fe37e7fbb","type":"text","text":"## Hash Table","x":-254,"y":-198,"width":324,"height":100,"color":"6"},
		{"id":"c54c1ca83c52d206","type":"text","text":"將 key 傳入 hash function，得到一個 hash value，用這個 hash value 當作 index 找到 array 中的對應位置，存入 value","x":-319,"y":24,"width":310,"height":171},
		{"id":"9703c525596317a6","type":"text","text":"#### Direct-Access Table","x":-835,"y":-180,"width":276,"height":65},
		{"id":"d166487b392a59d4","type":"text","text":"假設有以下資料要儲存：\n\n```json\n{\n    \"0\": \"Alice\",\n    \"1\": \"Bob\",\n    \"8\": \"Cathy\"\n}\n```\n\n以 direct-access table 儲存就會是：\n\n```Python\ndata = [\n    \"Alice\",\n    \"Bob\",\n    None,\n    None,\n    None,\n    None,\n    None,\n    None,\n    \"Cathy\",\n]\n```","x":-1117,"y":265,"width":340,"height":625},
		{"id":"973e41a40f72d4b0","type":"text","text":"以 array 作為資料的資料結構，且直接用 key 當作 index，找到 array 中的對應位置，存入 value","x":-1101,"y":24,"width":310,"height":135},
		{"id":"d68746b2f77d4bdc","type":"text","text":"###### Pros\n\n- Key 不須經過 hash function\n- 實作簡單\n\n###### Cons\n\n- Table 的空間複雜度為 $O(max(key))$，所以 key 的最大值不能超過硬體限制","x":-717,"y":24,"width":302,"height":359},
		{"id":"5c8c40bb2462f10f","type":"text","text":"###### Pros\n\n- Key 的大小沒有上限\n\n###### Cons\n\n- 有可能出現 **hash collision**","x":70,"y":31,"width":303,"height":256},
		{"id":"9fe0f2ea3d9f5d10","type":"text","text":"不可逆（無法找到一個 inverse function 可以以 hash value 為 input 並輸出原始值）","x":539,"y":-429,"width":408,"height":99},
		{"id":"25f41d183c73cb2c","type":"text","text":"無論 input 的長度為何，output 的長度固定","x":539,"y":-290,"width":408,"height":58},
		{"id":"69d257dd1e3626cb","type":"text","text":"即使兩段 inputs 的內容相近，得到的 outputs 通常也會截然不同","x":539,"y":-180,"width":408,"height":99},
		{"id":"93528f1d5abcfa39","type":"text","text":"###### Simple Uniform Hashing\n\n一個 hash function 在 hash 多個隨機的 keys 後，得到的 hash values 趨於 uniform distribution，但任一個 key 的 hash value 都不會因為現有的分佈狀況而被影響。","x":539,"y":-40,"width":408,"height":232},
		{"id":"b594fc13486b57e3","type":"text","text":"```Python\nclass HashTable:\n    def __init__(self, prime: int = 191) -> None:\n        self.__prime = prime\n        self.__data = []\n\n    def put(self, key: int | float | str, value) -> None:\n        hash_value = self.__division_hash(key)\n        if (diff := hash_value + 1 - len(self.__data)) > 0:\n            self.__data += [None] * diff\n            self.__data[hash_value] = [key, value]\n        else:\n            while hash_value < len(self.__data):\n                if self.__data[hash_value] is None:\n                    self.__data[hash_value] = [key, value]\n                    return\n                elif self.__data[hash_value][0] == key:\n                    self.__data[hash_value][1] = value\n                    return\n                hash_value += 1  # linear probing\n            self.__data.append([key, value])\n\n    def get(self, key: int | float | str):\n        hash_value = self.__division_hash(key)\n        while hash_value < len(self.__data):\n            if self.__data[hash_value] is None:\n                return None\n            elif self.__data[hash_value][0] == key:\n                return self.__data[hash_value][1]\n            hash_value += 1\n        return None\n\n    def __division_hash(self, x: int | float | str) -> int:\n        if isinstance(x, int):\n            return x % self.__prime\n        return int(\"\".join([str(ord(char)) for char in str(x)])) % self.__prime\n```","x":587,"y":330,"width":812,"height":887},
		{"id":"959b11de656785cf","type":"text","text":"#### Chaining\n\n- 使用 linked list 把得到同一個 hash 的資料串起來\n- 得到相同 key 的一串 linked list 稱為 **bucket**\n- Bucket 內每一筆資料的 key 與 value 都要存\n- Time Complexity\n    - Get: $O(1 + \\large{m \\over n})$\n    - Put: $O(1 + \\large{m \\over n})$\n    - m 為 key 集合的大小；n 為 hash value 值域的大小，並假設 hash function 的複雜度為 $O(1)$","x":1584,"y":96,"width":473,"height":439},
		{"id":"55f7587bbd32b73c","type":"text","text":"```Python\nclass HashTable:\n    def __init__(self, prime: int = 191) -> None:\n        self.__prime: int = prime\n        self.__data: list = [None] * self.__prime\n\n    def put(self, key: int | float | str, value) -> None:\n        bucket = self.__data[self.__division_hash(key)]\n        if bucket is None:\n            self.__data[self.__division_hash(key)] = [[key, value]]\n            return\n        for k, v in bucket:\n            if k == key:\n                v = value\n                return\n        bucket.append([key, value])\n\n    def get(self, key: int | float | str):\n        bucket = self.__data[self.__division_hash(key)]\n        if bucket:\n            for k, v in bucket:\n                if k == key:\n                    return v\n        return None\n\n    def __division_hash(self, x: int | float | str) -> int:\n        if isinstance(x, int):\n            return x % self.__prime\n        return int(\"\".join([str(ord(char)) for char in str(x)])) % self.__prime\n```","x":2282,"y":193,"width":812,"height":731},
		{"id":"89c61f022d659b4a","type":"file","file":"img/hash-table-chaining.png","x":2282,"y":-98,"width":350,"height":256},
		{"id":"da03bc238e5b7634","type":"text","text":"#### Open Addressing\n\n- 如果 hash as index 的位置已經有值，就往後找還空著的地方來存\n    - 「往後找」這個動作叫 probing\n- Probing 分為 linear、quadratic、random 等方式\n- Key 與 value 都要存在 value 中","x":1584,"y":616,"width":473,"height":315},
		{"id":"f47cede75563f299","type":"text","text":"```Python\ndef division_hash(x) -> int:\n    prime = 191\n    if isinstance(x, int):\n        return x % prime\n    return int(\"\".join([str(ord(char)) for char in str(x)])) % prime\n```","x":1680,"y":-1527,"width":702,"height":205},
		{"id":"a066e0d821a88c5f","type":"text","text":"n 最好要避開 2 的正整數次方與 10 的正整數次方，否則會很常發生 **hash collision**\n","x":1680,"y":-1274,"width":385,"height":100},
		{"id":"d4d8bdd8f6b18989","type":"text","text":"Hash value 的值域會是 $[0, n-1]$","x":1680,"y":-1123,"width":308,"height":64},
		{"id":"de67fa23487d9a3b","type":"text","text":"因為 k 除以 $2^m$ 會等於取 k 的末 m 個 bits；k 除以 $10^m$ 則等同於取 k 的末 m 位數","x":2146,"y":-1274,"width":394,"height":100},
		{"id":"3dfe5f115b894f31","type":"text","text":"實驗證明當 n 為一個「離 2 的正整數次方夠遠的質數」時，hash function 的表現較好","x":2146,"y":-1141,"width":396,"height":100},
		{"id":"a648b5a61cc8fafc","type":"text","text":"#### Division Method\n\n- 先將輸入值 encode 成整數 k\n- 決定一個正整數 n\n- 計算 $k \\mod n$\n\n$$\nh(k) = k \\mod n\n$$","x":1073,"y":-1377,"width":458,"height":332},
		{"id":"52cc2070e0e45cb3","type":"text","text":"這些簡單的 hash functions 因為缺陷太多了，所以實務上不會用","x":1181,"y":-1633,"width":242,"height":135},
		{"id":"01103ea060f151a9","type":"text","text":"#### Multiplication Method\n\n- 將輸入值 encode 成整數 k\n- 決定一個介於 0 ~ 1（開區間）的實數常數 a、一個常數 m，其中 m 必須是 2 的正整數次方\n- 將 k 乘以 a，得到 s\n- 取 s 的小數部位，令其為 x\n- 將 x 乘以 m，並取整數部位，即得到 hash value\n\n$$\nh(k) = \\lfloor ((k \\cdot a) \\mod 1) \\cdot m \\rfloor\n$$","x":1073,"y":-1025,"width":458,"height":487},
		{"id":"8da0ba0e989a9d7e","type":"text","text":"```Python\ndef multiplication_hash(x) -> int:\n    a, b, m = 61803, 10**5, 191\n    x = int(\"\".join([str(ord(char)) for char in str(x)]))\n    return x * a % b * m // b\n```","x":1664,"y":-868,"width":607,"height":173},
		{"id":"373f2f8a5b8bf3a6","type":"text","text":"###### Hash Collision\n\n- 由於 output 的值域較 input 窄（input 的值域無限），所以有可能輸入不同 input 卻得到相同 output，這叫做 hash collision\n- 好的 hash function 應該盡可能不要出現 hash collision","x":1058,"y":-393,"width":528,"height":264}
	],
	"edges":[
		{"id":"6acf74a5e71ffa9c","fromNode":"a196e5ac56db1698","fromSide":"top","toNode":"f86f8d1d2b74b019","toSide":"bottom"},
		{"id":"145f839c2215acdc","fromNode":"a196e5ac56db1698","fromSide":"bottom","toNode":"73842961c770f581","toSide":"top"},
		{"id":"2e68a5d872fb9576","fromNode":"a196e5ac56db1698","fromSide":"left","toNode":"271c87cc8cc5b7d4","toSide":"right"},
		{"id":"aefea43ec2100192","fromNode":"a196e5ac56db1698","fromSide":"top","toNode":"aa47004104c96f1a","toSide":"bottom"},
		{"id":"90be8db923b510f1","fromNode":"26accb2fe37e7fbb","fromSide":"bottom","toNode":"c54c1ca83c52d206","toSide":"top","label":"idea"},
		{"id":"50bf752c7979a0df","fromNode":"9703c525596317a6","fromSide":"bottom","toNode":"973e41a40f72d4b0","toSide":"top","label":"idea"},
		{"id":"82ba48597b3e5505","fromNode":"9703c525596317a6","fromSide":"bottom","toNode":"d68746b2f77d4bdc","toSide":"top","label":"優缺點"},
		{"id":"9bb54e1441efc7f5","fromNode":"973e41a40f72d4b0","fromSide":"bottom","toNode":"d166487b392a59d4","toSide":"top"},
		{"id":"788cc7ce8ca4cbdc","fromNode":"26accb2fe37e7fbb","fromSide":"bottom","toNode":"5c8c40bb2462f10f","toSide":"top","label":"優缺點"},
		{"id":"75b8b77865df514c","fromNode":"a648b5a61cc8fafc","fromSide":"right","toNode":"f47cede75563f299","toSide":"left","label":"code"},
		{"id":"063503ad00ae3eb8","fromNode":"a196e5ac56db1698","fromSide":"right","toNode":"f389fc1d07a58b1c","toSide":"left","label":"範例"},
		{"id":"3f747ce9cec7919c","fromNode":"25f41d183c73cb2c","fromSide":"right","toNode":"373f2f8a5b8bf3a6","toSide":"left"},
		{"id":"486320266d980a47","fromNode":"a196e5ac56db1698","fromSide":"top","toNode":"8c49bf9b00379b01","toSide":"bottom"},
		{"id":"122047d95182673d","fromNode":"a196e5ac56db1698","fromSide":"top","toNode":"7289a4c60b56d99c","toSide":"bottom"},
		{"id":"42ec34e0c6f87710","fromNode":"8c49bf9b00379b01","fromSide":"top","toNode":"2fd997835d4fc628","toSide":"bottom"},
		{"id":"bb3febaa6df8de33","fromNode":"959b11de656785cf","fromSide":"right","toNode":"55f7587bbd32b73c","toSide":"left","label":"code"},
		{"id":"374000df2b851779","fromNode":"959b11de656785cf","fromSide":"right","toNode":"89c61f022d659b4a","toSide":"left","label":"visualize"},
		{"id":"85b85d0f155e2d25","fromNode":"271c87cc8cc5b7d4","fromSide":"left","toNode":"78cddbf39f2cc15b","toSide":"right"},
		{"id":"7428246e59c8939f","fromNode":"a196e5ac56db1698","fromSide":"bottom","toNode":"f4e489738c973c82","toSide":"top","color":"6","label":"應用"},
		{"id":"237bdc277934d9c0","fromNode":"373f2f8a5b8bf3a6","fromSide":"right","toNode":"ef217910f14bec4e","toSide":"top"},
		{"id":"295565c1ec38915b","fromNode":"a648b5a61cc8fafc","fromSide":"right","toNode":"a066e0d821a88c5f","toSide":"left"},
		{"id":"b4632223eeab6dcb","fromNode":"f389fc1d07a58b1c","fromSide":"top","toNode":"52cc2070e0e45cb3","toSide":"bottom"},
		{"id":"7c336977aab75175","fromNode":"a648b5a61cc8fafc","fromSide":"right","toNode":"d4d8bdd8f6b18989","toSide":"left"},
		{"id":"bebc291bedffb509","fromNode":"a066e0d821a88c5f","fromSide":"right","toNode":"de67fa23487d9a3b","toSide":"left"},
		{"id":"0b9ac3932d7fc6cf","fromNode":"a066e0d821a88c5f","fromSide":"right","toNode":"3dfe5f115b894f31","toSide":"left"},
		{"id":"a767196506acdc10","fromNode":"da03bc238e5b7634","fromSide":"left","toNode":"b594fc13486b57e3","toSide":"right","label":"code"},
		{"id":"2eb417831efe5e4a","fromNode":"01103ea060f151a9","fromSide":"right","toNode":"8da0ba0e989a9d7e","toSide":"left","label":"code"}
	]
}