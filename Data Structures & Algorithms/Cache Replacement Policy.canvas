{
	"nodes":[
		{"id":"b9cf4e474ec87dde","type":"text","text":"least frequently used","x":1573,"y":-519,"width":229,"height":61},
		{"id":"c05fd1b6fec3d86e","type":"text","text":"#### LFU Cache","x":1304,"y":-429,"width":175,"height":56,"color":"5"},
		{"id":"0302a51d5d88567f","type":"text","text":"缺點：有可能存在一些因為過去很常被使用而在 cache 裡有很高 priority 的資料，這些資料可能現在不再需要了","x":1605,"y":-399,"width":286,"height":176},
		{"id":"10b247dec221b176","type":"text","text":"[相關文章 1](https://redis.com/glossary/lru-cache/)","x":-857,"y":-587,"width":154,"height":54},
		{"id":"71fbe63774c2bfa9","type":"text","text":"#### LRU Cache","x":-568,"y":-509,"width":177,"height":56,"color":"5"},
		{"id":"9b41ba365c225fb7","type":"text","text":"多一個 doubly-linked list 紀錄順序","x":-825,"y":-14,"width":215,"height":96},
		{"id":"44d1fc4842b1ea2f","type":"text","text":"```Python\ntype primary = str | int | float | tuple[primary, ...]\n\nclass Node:\n    def __init__(self, key: primary, value) -> None:\n        self.key = key\n        self.value = value\n        self.prev: Node | None = None\n        self.next: Node | None = None\n\n\nclass LRUCache:\n    def __init__(self, size: int) -> None:\n        self.max_size = size\n        self.__storage = {}\n        self.__head: Node | None = None\n        self.__tail: Node | None = None\n\n    @property\n    def size(self) -> int:\n        return len(self.__storage)\n\n    def get(self, key: primary):\n        value = self.__storage[key].value\n        self.set(key, value)\n        return value\n\n    def set(self, key: primary, value) -> None:\n        # remove old node from the hash map and the linked list if found\n        if old_node := self.__storage.pop(key, None):\n            if self.__head and old_node is self.__head:\n                self.__head = self.__head.next\n            else:\n                old_node.prev.next = old_node.next\n            if self.__tail and old_node is self.__tail:\n                self.__tail = self.__tail.prev\n            else:\n                old_node.next.prev = old_node.prev\n\n        # remove head if capacity is full\n        if self.size >= self.max_size and self.__head:\n            del self.__storage[self.__head.key]\n            self.__head = self.__head.next\n\n        # create new node, put it into the hash map and the linked list\n        new_node = Node(key, value)\n        self.__storage[key] = new_node\n        if not self.__head or not self.__tail:\n            self.__head = self.__tail = new_node\n        else:\n            new_node.prev = self.__tail\n            self.__tail.next = new_node\n            self.__tail = self.__tail.next\n```","x":-1085,"y":310,"width":737,"height":1266},
		{"id":"e5fb45ad670a0614","type":"text","text":"least recently used","x":-303,"y":-509,"width":210,"height":60},
		{"id":"8834d09658708173","type":"text","text":"- 瀏覽器暫存網頁\n- OS 分配 memory page\n- [[CDN]]\n- Database cache","x":-1156,"y":-514,"width":243,"height":221},
		{"id":"80a1bd048117b004","type":"text","text":"應用","x":-825,"y":-449,"width":88,"height":54},
		{"id":"e8b7b26e76781ed0","type":"text","text":"實作","x":-523,"y":-193,"width":88,"height":54},
		{"id":"80612e3000c36eba","type":"text","text":"```Python\nfrom collections import OrderedDict\n\ntype primary = str | int | float | tuple[primary, ...]\n\n\nclass LRUCache:\n    def __init__(self, size: int) -> None:\n        self.max_size = size\n        self.__storage = OrderedDict()\n    \n    @property\n    def size(self) -> int:\n        return len(self.__storage)\n    \n    def get(self, key: primary):\n        value = self.__storage[key]\n        self.set(key, value)\n        return value\n    \n    def set(self, key: primary, value) -> None:\n        self._storage.pop(key, None)\n        if self.size >= self.max_size:\n            self.__storage.popitem(last=False)\n        self.__storage[key] = value\n```","x":-1055,"y":1766,"width":677,"height":642},
		{"id":"e0a1810ad6ea93b6","type":"text","text":"變體","x":285,"y":-74,"width":88,"height":54},
		{"id":"0151d8285f5b7901","type":"text","text":"兼顧 frequency 與 recency","x":-283,"y":548,"width":269,"height":64},
		{"id":"c3ef557e64f21c1a","type":"text","text":"Segmented LRU (SLRU)","x":-277,"y":181,"width":257,"height":64},
		{"id":"e243a02142f698b9","type":"text","text":"將 cache 分兩組，其中一組是只被 access 一次的；另外一組是被 access 超過一次的","x":-260,"y":324,"width":224,"height":169},
		{"id":"a60e47b118e791bf","type":"text","text":"Pseudo LRU (PLRU)","x":103,"y":181,"width":226,"height":61},
		{"id":"6c1c51b5e8407ff6","type":"text","text":"Tree PLRU","x":143,"y":335,"width":145,"height":54},
		{"id":"dde35dc0834dc5db","type":"text","text":"- 缺點：removal 的 time complexity 較高（$O(\\log n)$）\n- 優點：較省 memory","x":70,"y":484,"width":292,"height":154},
		{"id":"79630be707ab58d6","type":"text","text":"Low Inter-reference Recency Set (LIRS)","x":737,"y":181,"width":222,"height":98},
		{"id":"efc9b444fe32d757","type":"text","text":"Adaptive Replacement Cache (ARC)","x":413,"y":181,"width":242,"height":100},
		{"id":"e2fd4ef3a4992525","type":"text","text":"多一個 hash map 紀錄每個使用次數有哪些資料（這些資料以 doubly-linked list 儲存）","x":1248,"y":20,"width":288,"height":140},
		{"id":"924ef5f113840eeb","type":"text","text":"```Python\nfrom collections import OrderedDict, defaultdict\n\ntype primary = str | int | float | tuple[primary, ...]\n\nclass LFUNode:\n    def __init__(self, value) -> None:\n        self.value = value\n        self.frequency = 1\n\nclass LFUCache:\n    def __init__(self, capacity: int) -> None:\n        self.capacity = capacity\n        self._storage: dict[primary, LFUNode] = {}\n        self._freqency_map = defaultdict(OrderedDict)\n        self._min_frequency = 0\n\n    @property\n    def size(self) -> int:\n        return len(self._storage)\n\n    def get(self, key: primary):\n        if node := self._storage.get(key):\n            self.set(key, node.value)\n            return node.value\n        else:\n            raise KeyError\n\n    def set(self, key: primary, value) -> None:\n        if node := self._storage.get(key):\n            self._freqency_map[node.frequency].pop(key)\n            if (\n                self._min_frequency == node.frequency\n                and len(self._freqency_map[node.frequency]) == 0\n            ):\n                self._min_frequency += 1\n            node.frequency += 1\n            node.value = value\n            self._freqency_map[node.frequency][key] = node\n        else:\n            if self.size >= self.capacity:\n                key_removed, _ = self._freqency_map[self._min_frequency].popitem(\n                    last=False\n                )\n                del self._storage[key_removed]\n            self._storage[key] = self._freqency_map[1][key] = LFUNode(value)\n            self._min_frequency = 1\n```","x":982,"y":313,"width":821,"height":1132},
		{"id":"fabe16447b626521","type":"text","text":"frequency-based policy","x":929,"y":-735,"width":248,"height":64},
		{"id":"d7f853006833e89a","type":"text","text":"recency based policy","x":230,"y":-765,"width":226,"height":61},
		{"id":"c5c5824916969474","type":"text","text":"#### MRU Cache","x":442,"y":-519,"width":185,"height":57,"color":"5"},
		{"id":"cc5d9c0f9ff7172a","type":"text","text":"適合存取行為具有循環性的情境","x":543,"y":-322,"width":304,"height":64},
		{"id":"3e97c3b944d5e830","type":"text","text":"a → b → c → d → a → b → c → d → ...","x":588,"y":-183,"width":214,"height":96},
		{"id":"0fbbd9d25a5f23b2","type":"text","text":"實作","x":1348,"y":-208,"width":88,"height":54},
		{"id":"3872f18e9b59ba8e","type":"text","text":"most recently used","x":716,"y":-520,"width":211,"height":60},
		{"id":"6b69ef02eb3c6368","type":"text","text":"有些程式語言中原生就有 lined hash map，比如 Java 的 `LinkedHashMap` 與 Python 的 `OrderedDict`","x":-1192,"y":-53,"width":279,"height":171},
		{"id":"4f2ad4230ce2e802","type":"text","text":"其實自從 Python3.7 後，一般的 `dict` 就是有序的，但是 `dict` 不支援從「頭」拿東西","x":-1580,"y":-36,"width":292,"height":135},
		{"id":"626cc11e548d08dd","type":"text","text":"#### LRU Cache with TTL, Fallback, and Thread Safety\n\n```Python\nfrom collections import OrderedDict\nfrom datetime import datetime, timedelta\nfrom threading import Lock\nfrom typing import Any, Callable\n\ntype primary = str | int | float | tuple[primary, ...]\n\n\nclass LRUCache:\n    def __init__(self, size: int, detault_ttl: int = 86400) -> None:\n        self.max_size = size\n        self.__storage = OrderedDict()\n        self.__lock = Lock()\n        self.__default_ttl = default_ttl\n        self.__expiration: dict[primary, datetime] = {}\n    \n    @property\n    def size(self) -> int:\n        return len(self.keys)\n\n    @property\n    def keys(self) -> list:\n        now = datetime.now()\n        return [key for key in self._storage if now <= self.__expiration[key]]\n\n    def get(\n        self,\n        key: primary,\n        refresh: bool = False,\n        refresh_ttl: int | None = None,\n        fallback: Callable | None = None,\n    ) -> Any:\n        now = datetime.now()\n        try:\n            if now > self.__expiration[key]:\n                del self._storage[key]\n                del self.__expiration[key]\n            value = self.__storage[key]\n        except KeyError:\n            if fallback is None:\n                raise Exception(\"Cache missed, and no fallback was provided.\")\n            value = fallback()\n        self.set(\n            key,\n            value,\n            ttl=(\n                refresh_ttl\n                if refresh\n                else int((self.__expiration[key] - now).total_seconds())\n            ),\n        )\n        return value\n\n    def set(self, key: primary, value: Any, ttl: int | None = None) -> None:\n        with self.__lock:\n            now = datetime.now()\n            ttl = ttl if ttl is not None else self.__default_ttl\n            self.__expiration[key] = now + timedelta(seconds=ttl)\n            if self.size >= self.max_size:\n                self._storage.popitem(last=False)\n            self.__storage[key] = value\n```","x":-1113,"y":2634,"width":793,"height":1526},
		{"id":"ab0121db7a7fded0","type":"text","text":"可以更好的地方：\n\n- Fallback action in the `get` method when \"cache missed\"\n- Assure thread safety\n- Set TTL (time to live)\n","x":362,"y":2287,"width":504,"height":242},
		{"id":"2de27ce6d945c0e2","type":"text","text":"又叫 cache eviction","x":1198,"y":-1198,"width":213,"height":60},
		{"id":"46cc83bda5c9aaab","type":"text","text":"在有限的空間中決定要將哪些資料 cache，以極大化 cache hit 的機率","x":1198,"y":-1062,"width":247,"height":135},
		{"id":"ae2367a7bbcaafba","type":"text","text":"## Cache  Replacement Policy","x":354,"y":-1044,"width":682,"height":100,"color":"6"},
		{"id":"cf1e23f2491f1a52","type":"text","text":"- [相關文章 1](https://redis.com/glossary/cache-invalidation/)\n- [相關文章 2](https://en.wikipedia.org/wiki/Cache_replacement_policies)\n- [相關影片](https://www.youtube.com/watch?v=_Hh-NcdbHCY&sttick=0)","x":608,"y":-1344,"width":174,"height":161},
		{"id":"fb21c9e490fd47bf","type":"text","text":"Cache 可以使用 hash map 實作","x":-77,"y":-1026,"width":307,"height":64}
	],
	"edges":[
		{"id":"ed24469fb7940a6f","fromNode":"ae2367a7bbcaafba","fromSide":"bottom","toNode":"d7f853006833e89a","toSide":"top"},
		{"id":"636fc09b16a95b24","fromNode":"71fbe63774c2bfa9","fromSide":"right","toNode":"e5fb45ad670a0614","toSide":"left"},
		{"id":"2236bdc83df279af","fromNode":"ae2367a7bbcaafba","fromSide":"right","toNode":"2de27ce6d945c0e2","toSide":"left"},
		{"id":"b8aa0dfa3b8fe157","fromNode":"ae2367a7bbcaafba","fromSide":"right","toNode":"46cc83bda5c9aaab","toSide":"left"},
		{"id":"5e2b82f6c1e32045","fromNode":"ae2367a7bbcaafba","fromSide":"bottom","toNode":"fabe16447b626521","toSide":"top"},
		{"id":"368c9f37792529a0","fromNode":"c05fd1b6fec3d86e","fromSide":"right","toNode":"b9cf4e474ec87dde","toSide":"left"},
		{"id":"dc031bb350912ced","fromNode":"71fbe63774c2bfa9","fromSide":"bottom","toNode":"e8b7b26e76781ed0","toSide":"top"},
		{"id":"071fd0db56e9a091","fromNode":"9b41ba365c225fb7","fromSide":"bottom","toNode":"44d1fc4842b1ea2f","toSide":"top","label":"Python"},
		{"id":"e3b687d0106910ec","fromNode":"c05fd1b6fec3d86e","fromSide":"bottom","toNode":"0fbbd9d25a5f23b2","toSide":"top"},
		{"id":"e6b7fc0f699e6b0a","fromNode":"e2fd4ef3a4992525","fromSide":"bottom","toNode":"924ef5f113840eeb","toSide":"top","label":"Python"},
		{"id":"7be583003f8be875","fromNode":"9b41ba365c225fb7","fromSide":"left","toNode":"6b69ef02eb3c6368","toSide":"right"},
		{"id":"16587278fde98833","fromNode":"6b69ef02eb3c6368","fromSide":"left","toNode":"4f2ad4230ce2e802","toSide":"right"},
		{"id":"722f7d08f546ba94","fromNode":"ab0121db7a7fded0","fromSide":"bottom","toNode":"626cc11e548d08dd","toSide":"top"},
		{"id":"d908e912bcf787d8","fromNode":"71fbe63774c2bfa9","fromSide":"left","toNode":"10b247dec221b176","toSide":"right"},
		{"id":"b19625aa79087cca","fromNode":"e8b7b26e76781ed0","fromSide":"left","toNode":"9b41ba365c225fb7","toSide":"top"},
		{"id":"df73b8072f4db12a","fromNode":"71fbe63774c2bfa9","fromSide":"left","toNode":"80a1bd048117b004","toSide":"right"},
		{"id":"3da80421a2dfd51a","fromNode":"80a1bd048117b004","fromSide":"left","toNode":"8834d09658708173","toSide":"right"},
		{"id":"4e47259e9a1e027e","fromNode":"ae2367a7bbcaafba","fromSide":"top","toNode":"cf1e23f2491f1a52","toSide":"bottom"},
		{"id":"2ed2ba7e15eae5ff","fromNode":"c05fd1b6fec3d86e","fromSide":"right","toNode":"0302a51d5d88567f","toSide":"left"},
		{"id":"a03a363d1915a75f","fromNode":"0fbbd9d25a5f23b2","fromSide":"bottom","toNode":"e2fd4ef3a4992525","toSide":"top"},
		{"id":"17d4e86737676c7d","fromNode":"71fbe63774c2bfa9","fromSide":"bottom","toNode":"e0a1810ad6ea93b6","toSide":"top"},
		{"id":"39467c7efb5278da","fromNode":"e0a1810ad6ea93b6","fromSide":"bottom","toNode":"c3ef557e64f21c1a","toSide":"top"},
		{"id":"41a94725f764fc45","fromNode":"e0a1810ad6ea93b6","fromSide":"bottom","toNode":"79630be707ab58d6","toSide":"top"},
		{"id":"06f888e9f6f27943","fromNode":"e0a1810ad6ea93b6","fromSide":"bottom","toNode":"a60e47b118e791bf","toSide":"top"},
		{"id":"c05341799ded7423","fromNode":"e0a1810ad6ea93b6","fromSide":"bottom","toNode":"efc9b444fe32d757","toSide":"top"},
		{"id":"39bdfc765684d83c","fromNode":"44d1fc4842b1ea2f","fromSide":"bottom","toNode":"80612e3000c36eba","toSide":"top","label":"改用 OrderedDict"},
		{"id":"6a3b0a4df3b11599","fromNode":"c3ef557e64f21c1a","fromSide":"bottom","toNode":"e243a02142f698b9","toSide":"top"},
		{"id":"b5fa913eada09191","fromNode":"e243a02142f698b9","fromSide":"bottom","toNode":"0151d8285f5b7901","toSide":"top"},
		{"id":"5a40f98e39aeca7d","fromNode":"d7f853006833e89a","fromSide":"bottom","toNode":"71fbe63774c2bfa9","toSide":"top"},
		{"id":"2484eef4309d41ee","fromNode":"d7f853006833e89a","fromSide":"bottom","toNode":"c5c5824916969474","toSide":"top"},
		{"id":"bd4fe2414483f85d","fromNode":"c5c5824916969474","fromSide":"right","toNode":"3872f18e9b59ba8e","toSide":"left"},
		{"id":"f9b2a41677d5c474","fromNode":"c5c5824916969474","fromSide":"bottom","toNode":"e8b7b26e76781ed0","toSide":"right"},
		{"id":"e6042256b6a4b58f","fromNode":"c5c5824916969474","fromSide":"bottom","toNode":"cc5d9c0f9ff7172a","toSide":"top"},
		{"id":"7244b22d0d282547","fromNode":"cc5d9c0f9ff7172a","fromSide":"bottom","toNode":"3e97c3b944d5e830","toSide":"top"},
		{"id":"65f60d14ff4cfa39","fromNode":"a60e47b118e791bf","fromSide":"bottom","toNode":"6c1c51b5e8407ff6","toSide":"top"},
		{"id":"5af6aaf2fc366643","fromNode":"6c1c51b5e8407ff6","fromSide":"bottom","toNode":"dde35dc0834dc5db","toSide":"top"},
		{"id":"e4597cb5a0e55ef9","fromNode":"924ef5f113840eeb","fromSide":"bottom","toNode":"ab0121db7a7fded0","toSide":"right"},
		{"id":"933fa5478385289a","fromNode":"fabe16447b626521","fromSide":"bottom","toNode":"c05fd1b6fec3d86e","toSide":"top"},
		{"id":"cb628ce15e08a2f0","fromNode":"80612e3000c36eba","fromSide":"right","toNode":"ab0121db7a7fded0","toSide":"top"},
		{"id":"209a27fca5d2bfd1","fromNode":"ae2367a7bbcaafba","fromSide":"left","toNode":"fb21c9e490fd47bf","toSide":"right"}
	]
}