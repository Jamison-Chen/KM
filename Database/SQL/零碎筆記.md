### 查詢目前的 Database User

```SQL
SELECT current_user;
```

---

### 註解

```SQL
-- 單行註解

/*
多
行
註
解
*/
```

---

### `DISTINCT`

```SQL
SELECT DISTINCT [column_a], [column_b], ... FROM [table_a];
```

回傳目前所有資料中的所有相異的 ([column_a], [column_b], ...) 組合。

e.g.

```SQL
SELECT COUNT(*) AS distinct_countries
FROM (
    SELECT DISTINCT country, city FROM customers
) AS subtable;
```

- 其實不一定要寫 `COUNT(*)`，可以用 `COUNT(0)` 代替之
- `AS distinct_countries` 是自訂的欄位名稱，可有可無，其中 `AS` 也可以省略
- `AS subtable` 不可省，一定要為 subquery 取名字
- 若 `DISTINCT` 只篩選一欄 `city`，則可簡寫為：`SELECT COUNT(DISTINCT city) FROM customers`

---

### `IN`

若 `IN` operator 的左方為 `null`，則無論右方有哪些值，一律 return `null`；若右方的 candidates 中沒有出現任何與左方相同的值，而且有出現過 `null`，則也是 return `null`，不是 return `false`。*（同樣的規則也適用於 `NOT IN`。）*

---

### `UNION` & `UNION ALL`

取左右兩個 relations 的「聯集」。兩個 relations 若要 `UNION`，則他們的 column 數量必須相同。

`UNION ALL` 與 `UNION` 的差別在於：若前後兩個 relations 擁有一模一樣的 row，則 `UNION ALL` 會如實顯示這些重複的 rows，`UNION` 只會讓同時出現在兩邊的 rows 出現一次。

---

### `COALESCE(a, b, …)`

依序看各個參數，直到看到不是 `null` 的為止，並回傳其值。

e.g. (1)

```SQL
SELECT COALESCE(null, null, 1, 2)
```

Output:

```plaintext
 coalesce 
----------
        1
(1 row)
```

e.g. (2)

```SQL
SELECT COALESCE(email, 'Email Not Exist') FROM student;
```

Output:

```plaintext
                coalesce                 
-----------------------------------------
 fmapstone0@goo.gl
 Email Not Exist
 Email Not Exist
 ndennett3@paginegialle.it
 lbrakespear4@thetimes.co.uk
 lgeraldi5@mapy.cz
 dgauvin6@senate.gov
 arisbridger7@symantec.com
 Email Not Exist
 nfish9@i2i.jp
 eswornea@shop-pro.jp
 ssalzbergb@pinterest.com
(12 rows)
```

---

### `NULLIF(a, b)`

若 a 等於 b，則回傳 `null`。

e.g. *(避免分母出現 0)*

```SQL
SELECT 1.0/NULLIF(COUNT(sid), 0)
FROM student
WHERE name LIKE 'Jami%';
```

---

### 不要再說 `count(*)` 會比較慢了

`SELECT * FROM <TABLE>;` 確實會因為 `*` 代表要輸出所有 columns 而比單獨 select 一個 column 慢，但 `SELECT COUNT(*) FROM <TABLE>;` 就不是這麼一回事了，相反地，`SELECT COUNT(*) FROM <TABLE>;` 反而是最有效率的，因為 `*` 的意思是讓 DBMS 自己從所有 column 中選擇最適合的 column 來 count。

那怎麼樣的 column 是最適合的 column 呢？

答案是 "==smallest secondary non-null index=="，讓我們來逐一拆解這個名詞的意思：

- Smallest 表示這個 column 的資料型態所佔的空間最小
- Secondary 表示這個 column 不能是 primary key（詳見[[Index#Secondary Index|本文]]）
- Non-null 表示這個 column 必須有 non-null constraint，因為數到 `NULL` 時不會 +1
- Index 表示這個 column 必須是這個 table 的 index 之一

在 MySQL 中，可以使用 `EXPLAIN` 來看是哪個 column 被拿來 count（PostgreSQL 的 `EXPLAIN` 沒有這個功能）：

```MySQL
EXPLAIN SELECT COUNT(*) FROM orders;
```

Output:

```plaintext
id  select_type  table   partitions  type   possible_keys  key              key_len  ref   rows   filtered  Extra
-----------------------------------------------------------------------------------------------------------------------
1   SIMPLE       orders  NULL        index  NULL           orders_from_ftb  2        NULL  44094  100.00    Using index
```

由此可見 `orders_from_ftb` 是 `orders` 這張表的 smallest secondary non-null index。

###### 參考資料

- <https://www.youtube.com/watch?v=H6juZ8c_Nu8>
- <https://www.cybertec-postgresql.com/en/postgresql-count-made-fast/>

---

### 判斷是否為 `null`

若要判斷某欄位是否為 `null`，正確的方式是 `<COLUMN> IS NULL` 或 `<COLUMN> IS NOT NULL`，不能使用 `<COLUMN> = NULL` 或 `<COLUMN> != NULL` 來判斷。

---
